//! An example of ZkSnarks math for demonstration purposes, not intended for production use

use crate::{
    error::Error,
    polynomial::Polynomial,
};
use curve25519_dalek::{
    constants::RISTRETTO_BASEPOINT_POINT, ristretto::RistrettoPoint, scalar::Scalar,
};

const G: RistrettoPoint = RISTRETTO_BASEPOINT_POINT;

/// Provers calculated curve points created by multiplying the polynomial coefficient
/// scalars by the challenge curve points
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ProverResponse {
    /// Evaluation of all polynomial coefficients at the challenge curve points
    pub(crate) px: RistrettoPoint,
    /// Evaluation of h(s) = p(s)/t(s) at the challenge curve points
    pub(crate) hx: RistrettoPoint,
    /// Evaluation of p(s*shift)
    pub(crate) px_shifted: RistrettoPoint,
}

impl ProverResponse {
    /// New encrypted response object
    pub fn new(px: RistrettoPoint, hx: RistrettoPoint, px_shifted: RistrettoPoint) -> Self {
        Self { px, hx, px_shifted }
    }
}

/// Verifier challenge
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Challenge {
    /// List of Ristretto curve points created by multiplying the secret scalar by the
    /// Ristretto basepoint
    encrypted_powers: Vec<RistrettoPoint>,
    /// List of Ristretto curve points created by shifting the encrypted powers by a
    /// secret scalar
    shifted_powers: Vec<RistrettoPoint>,
}

impl Challenge {
    /// Create a list of encrypted powers from a secret scalar. This
    pub fn new(scalar: &Scalar, shift: &Scalar, degree: usize) -> Self {
        let mut power = *scalar;
        let mut encrypted_powers = vec![G, scalar * G];
        let mut shifted_powers = vec![shift * G, shift * scalar * G];
        for _ in 1..degree {
            power *= scalar;
            encrypted_powers.push(power * G);
            shifted_powers.push((shift * power) * G);
        }
        Self {
            encrypted_powers,
            shifted_powers,
        }
    }

    /// Get encrypted powers and shifted powers
    pub fn get_challenge_powers(&self) -> (&Vec<RistrettoPoint>, &Vec<RistrettoPoint>) {
        (&self.encrypted_powers, &self.shifted_powers)
    }
}

/// Proof transcript object containing the verifiers generated values, the prover's
/// response values, and the verifier's evaluation of prover values. Note that this
/// currently is an interactive proof and is not yet verifiable by third parties.
/// This object provides the functionality for a single verifier to check that the
/// prover's response to the initially provided challenge values is correct.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SnarkProofTranscript {
    // Object containing vector of Ristretto curve points created by multiplying
    // the secret scalar, and the shift of the secret scalar by the Ristretto
    // basepoint
    challenge: Challenge,
    // Prover's evaluation of their secret polynomial against the challenge values
    // provided by the verifier
    prover_response: ProverResponse,
    // Evaluation of p(s) = h(s)*t(s) where h(s) and p(s) is provided by the prover
    // and t(s) by the verifier, proving that the prover does know polynomial p(s)
    cofactors_verification: RistrettoPoint,
    // Evaluation of p(s*shift) = h(s*shift)*t(s*shift) where h(s*shift) and p(s*shift)
    // is provided by the prover and t(s) by the verifier, proving that the prover
    // applied the exact powers provided by the verifier
    power_verification: RistrettoPoint,
}

impl SnarkProofTranscript {
    /// Create a new proof transcript
    pub fn new(
        challenge: Challenge,
        prover_response: ProverResponse,
        cofactors_verification: RistrettoPoint,
        power_verification: RistrettoPoint,
    ) -> Self {
        Self {
            challenge,
            prover_response,
            cofactors_verification,
            power_verification,
        }
    }

    /// Verify a prover response by multiplying t(s) the provers calculated curve points
    pub fn proof_is_valid(&self) -> bool {
        self.cofactors_verification == self.prover_response.px
            && self.power_verification == self.prover_response.px_shifted
    }
}

/// Verifier object generated by the trusted setup. In the interactive case this object
/// hold sensitive secrets that shouldn't be leaked often called "toxic waste". The reason
/// for this being necessary is that by themselves, elliptic curves Groups only have an
/// additive law P1 + P2 defined but no multiplicative laws where two points P1*P2 can be
/// multiplied together (or in abstract algebra terminology, Elliptic Curves are NOT rings
/// or fields).
///
/// Multiplying curve points by Scalars is not an actual multiplication but rather repeated
/// point additions P1 + P1 + .. + P1. Thus without a tool to multiply two points directly,
/// the scalars must be stored until they can be used.
///
/// Full interactivity would be provided if hidden scalars encoded into curve points could
/// be published and use to verify proofs directly. A technique called "Pairing" is often
/// used in ZkSnarks to enable direct "multiplication" curve points providing non-interactivity,
/// but not all elliptic curves (in this case Ristretto-25519) are suitable for this. Further
/// exploration of pairing are shown in other examples.
pub struct Verifier {
    // Evaluation of polynomial at secret scalar done with in the scalar field
    ts: Option<Scalar>,
    // Randomly generated secret shift scalar created to enforce the prover is using
    // a polynomial with degree they claim to have
    shift: Option<Scalar>,
}

impl Verifier {
    /// Create a new verifier object
    pub fn new(ts: Scalar, shift: Scalar) -> Self {
        Self {
            ts: Some(ts),
            shift: Some(shift),
        }
    }

    /// Evaluate prover's provided values by checking the following
    /// 1. The polynomial evaluates correctly at the secret scalar: p(s) = t(s)*h(s)
    /// 2. The polynomial evaluates correctly with the secret power shift: p(s*shift)
    /// = t(s*shift)*h(s*shift)
    ///
    /// The prover's response will include evaluations of h(s), p(s), and p(s*shift) as
    /// elliptic curve points. This function takes the stored shift scalar and scalar
    /// evaluation of t(s) and multiplies it by the prover's curve points to verify
    /// the prover's knowledge of the polynomial.
    ///
    /// This function is meant to be single-use to prevent discovery of the secret scalars.
    /// Once this function is applied, it will drop the scalars and return an error on the
    /// next usage.
    pub fn verify_proof(
        &mut self,
        prover_response: ProverResponse,
        challenge: Challenge,
    ) -> Result<SnarkProofTranscript, Error> {
        if self.ts.is_none() || self.shift.is_none() {
            return Err(Error::ProofAlreadyVerified);
        }
        let (ts, shift) = (self.ts.take().unwrap(), self.shift.take().unwrap());

        // Multiply stored scalars by the prover's curve points
        let cofactors_verification = ts * prover_response.hx;
        let power_verification = shift * prover_response.px;
        Ok(SnarkProofTranscript {
            challenge,
            prover_response,
            cofactors_verification,
            power_verification,
        })
    }
}

/// This function provides the "trusted setup" which generates random challenge values to be
/// used within the proof. It returns a verifier and a set of challenge values for a prover
/// to evaluate their polynomial at.
pub fn trusted_setup(target_polynomial: &Polynomial) -> (Verifier, Challenge) {
    let mut rng = rand::thread_rng();
    let shift = Scalar::random(&mut rng);
    let scalar = Scalar::random(&mut rng);
    let ts = target_polynomial.eval_public_polynomial(&scalar);
    (
        Verifier::new(ts, shift),
        Challenge::new(&scalar, &shift, target_polynomial.degree()),
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Root;

    #[test]
    fn test_encrypted_powers_calculate_correctly() {
        let scalar = Scalar::from(5u64);
        let shift = Scalar::from(2u64);
        let Challenge = Challenge::new(&scalar, &shift, 5);

        let (encrypted_powers, shifted_powers) = Challenge.get_challenge_powers();

        // Check encrypted powers match expected curve points
        assert_eq!(encrypted_powers.len(), 6);
        assert_eq!(encrypted_powers[0], G);
        assert_eq!(encrypted_powers[1], Scalar::from(5u64) * G);
        assert_eq!(encrypted_powers[2], Scalar::from(25u64) * G);
        assert_eq!(encrypted_powers[3], Scalar::from(125u64) * G);
        assert_eq!(encrypted_powers[4], Scalar::from(625u64) * G);
        assert_eq!(encrypted_powers[5], Scalar::from(3125u64) * G);

        // Check shifted powers match expected curve points
        assert_eq!(shifted_powers.len(), 6);
        assert_eq!(shifted_powers[0], shift * G);
        assert_eq!(shifted_powers[1], Scalar::from(2 * 5u64) * G);
        assert_eq!(shifted_powers[2], Scalar::from(2 * 25u64) * G);
        assert_eq!(shifted_powers[3], Scalar::from(2 * 125u64) * G);
        assert_eq!(shifted_powers[4], Scalar::from(2 * 625u64) * G);
        assert_eq!(shifted_powers[5], Scalar::from(2 * 3125u64) * G);
    }

    #[test]
    fn test_encrypted_coefficients_arent_exposed() {
        let roots = vec![
            Root::try_from((1, 2)).unwrap(),
            Root::try_from((3, 6)).unwrap(),
            Root::try_from((2, 4)).unwrap(),
        ];

        let polynomial = Polynomial::new(roots, 2).unwrap();
        let scalar = Scalar::from(5u64);
        let shift = Scalar::from(2u64);
        let challenge = Challenge::new(&scalar, &shift, 3);
        let response = polynomial.generate_response(&challenge);

        // Check polynomial is properly shifted and does NOT evaluate to unencrypted coefficients
        assert_eq!(polynomial.degree(), 3);
        assert_ne!(response.px, Scalar::from(2058u64) * G);
        assert_ne!(response.px_shifted, Scalar::from(4116u64) * G);
    }

    #[test]
    fn test_encrypted_proof_is_correct_and_cant_be_performed_twice() {
        let roots = vec![
            Root::try_from((1, 2)).unwrap(),
            Root::try_from((3, 6)).unwrap(),
            Root::try_from((2, 4)).unwrap(),
            Root::try_from((1, 8)).unwrap(),
            Root::try_from((1, 7)).unwrap(),
        ];

        let polynomial = Polynomial::new(roots, 2).unwrap();
        let (mut verifier, challenge) = trusted_setup(&polynomial);
        let prover_response = polynomial.generate_response(&challenge);

        let challenge2 = challenge.clone();
        let prover_response2 = polynomial.generate_response(&challenge2);

        let proof = verifier.verify_proof(prover_response, challenge).unwrap();
        let proof2 = verifier.verify_proof(prover_response2, challenge2);
        assert_eq!(proof2, Err(Error::ProofAlreadyVerified));
        assert!(proof.proof_is_valid());
        println!("{:?}", proof);
    }
}
